#!/usr/bin/python

import argparse
import datetime

from grub_api.database import Database
from grub_api.category import Category
from grub_api.text_interface import TextInterface
from grub_api.utils import Heading
from grub_api.product import Ingredient

def add_category(name, grub_db):
    grub_category = Category(name)
    grub_db.add_category(grub_category)

argparser = argparse.ArgumentParser(description="Command line to interact with the Grub database.")
argparser.add_argument('grub_input', help='The grub file to read from')
argparser.add_argument('-c','--category_edit', dest='edit_categories', action='store_true',
                       help='Edit the existing categories')
argparser.add_argument('-C','--category_new', dest='new_category', action='store',
                       help='Create a new category.')
argparser.add_argument('-s','--shopping_list', dest='shopping_list', action='store_true',
                       help='Generate a shopping list')
argparser.add_argument('-o','--output_path', dest='output_path', action='store',
                       help='Specifies output path')

args = argparser.parse_args()

grub_db = Database(file_path=args.grub_input)

if args.edit_categories:
    ti = TextInterface()
    for i in xrange(len(grub_db.categories)):
        c = grub_db.categories[i]
        ti.append("%d=%s" % (i+1, c.name))

    ti.append('=' * 60)

    for r in grub_db.recipes:
        prefix = ''
        for i in xrange(len(grub_db.categories)):
            c = grub_db.categories[i]
            if r in c.recipes:
                prefix += str(i+1)
            else:
                prefix += '-'
        ti.append( '%s %s' % (prefix, r.name))
    
    ti.run()

    # input_categories = []
    # for line in ti.get_line():
    #     if line.startswith("#"):
    #         input_categories.append(line[1:])

    # print input_categories

    # for i in range(len(input_categories)):
    #     if i < len(grub_db.categories):
    #         if not input_categories[i]:
    #             print "Category %s deleted" % grub_db.categories[i].name
    #             #TODO_ delete category 
    #         elif input_categories[i] != grub_db.categories[i].name:
    #             print "Category %s renamed to %s" % (grub_db.categories[i].name, input_categories[i])
    #             #TODO_ Update category
    #     else:
    #         print "New Category %s found" % input_categories[i] 
    #         add_category(input_categories[i], grub_db)
    
elif args.new_category:
    add_category(args.new_category, grub_db)

elif args.shopping_list:
    all_categories = grub_db.categories
    all_recipe_names = set([r.name for r in grub_db.recipes])
    recipes_in_categories = set()
    ti = TextInterface()
    for c in all_categories:
        ti.append('\n%s' % Heading(c.name))
        for r in sorted(c.recipes, key=lambda r: r.name):
            ti.append('- %s' % r.name)
            recipes_in_categories.add(r.name)
    ti.append('\nOther Recipes\n')
    for n in sorted(all_recipe_names - recipes_in_categories):
        ti.append('- %s' % n)
    ti.run()

    selected_recipes = []
    for line in ti.get_line():
        if line.startswith('Y '):
            selected_recipes.append(grub_db.find_recipe_by_name(line[2:]))

    ti = TextInterface()
    ti.append(Heading('Recipes'))
    required_ingredients = {} # maps product_name to map of units to ingredient
    for r in selected_recipes:
        ti.append("%s\n" % r)
        for i in r.ingredients:
            if i.product.name not in required_ingredients:
                required_ingredients[i.product.name] = {}
            if i.unit not in required_ingredients[i.product.name]:
                required_ingredients[i.product.name][i.unit] = Ingredient(i.product, 0, i.unit)
            required_ingredients[i.product.name][i.unit].amount += i.amount if i.amount else 0

    ti.append(Heading('Shopping List %s' % datetime.date.today()))
    for p in required_ingredients.values():
        for i in p.values():
            ti.append('%s' % i)
    ti.run()

if args.output_path:
    grub_db.save(args.output_path)
else:
    grub_db.save(args.grub_input)