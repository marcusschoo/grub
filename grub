#!/usr/bin/python

import argparse
import datetime

from grub_api.database import Database
from grub_api.category import Category
from grub_api.recipe import Recipe
from grub_api.text_interface import TextInterface
from grub_api.utils import Heading
from grub_api.product import Ingredient

def add_category(name, grub_db):
    grub_category = Category(name)
    grub_db.add_category(grub_category)

argparser = argparse.ArgumentParser(description="Command line to interact with the Grub database.")
argparser.add_argument('grub_input', help='The grub file to read from')
argparser.add_argument('-c','--category_edit', dest='edit_categories', action='store_true',
                       help='Edit the existing categories')
argparser.add_argument('-C','--category_new', dest='new_category', action='store',
                       help='Create a new category.')
argparser.add_argument('-s','--shopping_list', dest='shopping_list', action='store_true',
                       help='Generate a shopping list')
argparser.add_argument('-o','--output_path', dest='output_path', action='store',
                       help='Specifies output path')
argparser.add_argument('-R','--recipe_new', dest='recipe_new', action='store_true',
                       help='Create a new recipe.')
argparser.add_argument('-r','--recipe_edit', dest='recipe_edit', action='store',
                       help='Edit a recipe.')

args = argparser.parse_args()

grub_db = Database(file_path=args.grub_input)
if not args.output_path:
    grub_db.save(args.grub_input + '.backup')

if args.edit_categories:
    ti = TextInterface()
    for i in xrange(len(grub_db.categories)):
        c = grub_db.categories[i]
        ti.append("%d=%s" % (i+1, c.name))

    ti.append('=' * 60)

    for r in grub_db.recipes:
        prefix = ''
        for i in xrange(len(grub_db.categories)):
            c = grub_db.categories[i]
            if r in c.recipes:
                prefix += str(i+1)
            else:
                prefix += '-'
        ti.append( '%s %s' % (prefix, r.name))
    
    ti.run()

    deleted_categories = []
    processing_categories = True
    # clear all categories
    for c in grub_db.categories:
        c.recipes = []
    for line in ti.get_line():
        # check if we are switching from processing categories to recipes
        if line.startswith('==='):
            processing_categories = False
            continue
        if processing_categories:
            tokens = line.split('=')
            if len(tokens) == 2:
                index = int(tokens[0]) - 1
                name = tokens[1]
                if index < len(grub_db.categories):
                    if name:
                        if name != grub_db.categories[index].name:
                            print 'Updating %s to %s' % (grub_db.categories[index].name, name)
                            grub_db.categories[index].name = name
                    else:
                        print 'Removing %s' % grub_db.categories[index].name
                        deleted_categories.append(grub_db.categories[index].name)
                else:
                    raise Exception('Category index out of range (%d)' % index)
            else:
                raise Exception('Category name invalid format: %s' % line)
        elif not deleted_categories:
            # process recipes only if no categories were deleted
            recipe = grub_db.find_recipe_by_name(line[len(grub_db.categories)+1:])
            if not recipe:
                print 'recipe not found: %s' % line[len(grub_db.categories)+1:]
            for i in xrange(0, len(grub_db.categories)):
                if line[i] != '-':
                    grub_db.categories[i].recipes.append(recipe)

    grub_db.categories = [c for c in grub_db.categories if c.name not in deleted_categories]

elif args.new_category:
    add_category(args.new_category, grub_db)

elif args.shopping_list:
    all_categories = grub_db.categories
    all_recipe_names = set([r.name for r in grub_db.recipes])
    recipes_in_categories = set()
    ti = TextInterface()
    for c in all_categories:
        ti.append('\n%s' % Heading(c.name))
        for r in sorted(c.recipes, key=lambda r: r.name):
            ti.append('- %s' % r.name)
            recipes_in_categories.add(r.name)
    ti.append('\nOther Recipes\n')
    for n in sorted(all_recipe_names - recipes_in_categories):
        ti.append('- %s' % n)
    ti.run()

    selected_recipes = []
    for line in ti.get_line():
        if line.startswith('Y '):
            selected_recipes.append(grub_db.find_recipe_by_name(line[2:]))

    ti = TextInterface()
    ti.append(Heading('Recipes'))
    required_ingredients = {} # maps product_name to map of units to ingredient
    for r in selected_recipes:
        ti.append("%s\n" % r)
        for i in r.ingredients:
            if i.product.name not in required_ingredients:
                required_ingredients[i.product.name] = {}
            if i.unit not in required_ingredients[i.product.name]:
                required_ingredients[i.product.name][i.unit] = Ingredient(i.product, 0, i.unit)
            required_ingredients[i.product.name][i.unit].amount += i.amount if i.amount else 0

    ti.append(Heading('Shopping List %s' % datetime.date.today()))
    for p in required_ingredients.values():
        for i in p.values():
            ti.append('%s' % i)
    ti.run()

elif args.recipe_new:
    ti = TextInterface()
    ti.append('%s' % Recipe.get_recipe_template())
    ti.run()

elif args.recipe_edit:
    ti = TextInterface()
    ti.append('%s' % grub_db.find_recipe_by_name(args.recipe_edit))
    ti.run()

if args.output_path:
    grub_db.save(args.output_path)
else:
    grub_db.save(args.grub_input)